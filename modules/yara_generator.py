"""
PERSEPTOR v2.0 - YARA Rule Generator
Structured output with IoC category mapping, sanitized names, and severity scoring.
"""

import re
import uuid
from datetime import datetime
from typing import List, Dict, Optional
from modules.logging_config import get_logger

logger = get_logger("yara_generator")

# IoC type → YARA string modifiers
IOC_MODIFIER_MAP = {
    "ips": "ascii fullword",
    "domains": "ascii nocase",
    "urls": "ascii wide nocase",
    "email_addresses": "ascii nocase",
    "file_hashes": "ascii fullword",
    "filenames": "ascii nocase wide",
    "registry_keys": "ascii nocase wide",
    "process_names": "ascii nocase",
    "malicious_commands": "ascii wide nocase",
}

# IoC type → YARA rule metadata description
IOC_DESCRIPTION_MAP = {
    "ips": "Detects suspicious IP address indicators",
    "domains": "Detects suspicious domain indicators",
    "urls": "Detects suspicious URL indicators",
    "email_addresses": "Detects suspicious email address indicators",
    "file_hashes": "Detects files matching known malicious hashes",
    "filenames": "Detects suspicious filename indicators",
    "registry_keys": "Detects suspicious registry key access",
    "process_names": "Detects suspicious process name indicators",
    "malicious_commands": "Detects malicious command execution patterns",
}

# IoC type → severity
IOC_SEVERITY_MAP = {
    "ips": "medium",
    "domains": "medium",
    "urls": "medium",
    "email_addresses": "low",
    "file_hashes": "high",
    "filenames": "medium",
    "registry_keys": "high",
    "process_names": "high",
    "malicious_commands": "critical",
}

MAX_INDICATORS_PER_RULE = 50


def _sanitize_rule_name(name: str) -> str:
    """Sanitize a string for use as a YARA rule name (alphanumeric + underscore only)."""
    sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    sanitized = re.sub(r'_+', '_', sanitized)
    sanitized = sanitized.strip('_')
    if sanitized and sanitized[0].isdigit():
        sanitized = "rule_" + sanitized
    return sanitized[:64] or "unnamed_rule"


def _sanitize_string(value: str) -> str:
    """Escape special characters for YARA string values."""
    return value.replace('\\', '\\\\').replace('"', '\\"')


def _build_condition(count: int) -> str:
    """Build appropriate YARA condition based on indicator count."""
    if count <= 3:
        return "any of them"
    elif count <= 10:
        return "2 of them"
    elif count <= 25:
        return "3 of them"
    else:
        return f"{max(2, count // 10)} of them"


def generate_yara_rules(analysis_data: dict) -> List[dict]:
    """
    Generate structured YARA rules from analysis data.

    Returns a list of dicts: {name, description, rule, severity, ioc_type, ioc_count, tags}
    """
    rules = []
    current_date = datetime.now().strftime("%Y-%m-%d")
    iocs = analysis_data.get("indicators_of_compromise", {})

    for ioc_type, modifier in IOC_MODIFIER_MAP.items():
        indicators = iocs.get(ioc_type, [])
        if not indicators:
            continue

        # Limit indicators per rule
        indicators = indicators[:MAX_INDICATORS_PER_RULE]

        rule_name = _sanitize_rule_name(f"PERSEPTOR_{ioc_type}_Detection")
        description = IOC_DESCRIPTION_MAP.get(ioc_type, f"Detects suspicious {ioc_type}")
        severity = IOC_SEVERITY_MAP.get(ioc_type, "medium")

        # Build YARA strings section
        yara_strings = []
        for idx, ioc in enumerate(indicators):
            safe_ioc = _sanitize_string(str(ioc))
            var_name = f"${ioc_type}_{idx}"
            yara_strings.append(f'        {var_name} = "{safe_ioc}" {modifier}')

        strings_block = "\n".join(yara_strings)
        condition = _build_condition(len(indicators))

        # Build complete rule
        rule_text = f"""rule {rule_name}
{{
    meta:
        description = "{description}"
        author = "PERSEPTOR - Aytek AYTEMUR"
        date = "{current_date}"
        severity = "{severity}"
        ioc_type = "{ioc_type}"
        reference = "Generated by PERSEPTOR AI Detection Platform"
        rule_id = "{str(uuid.uuid4())[:8]}"

    strings:
{strings_block}

    condition:
        {condition}
}}"""

        rules.append({
            "name": rule_name,
            "description": description,
            "rule": rule_text,
            "severity": severity,
            "ioc_type": ioc_type,
            "ioc_count": len(indicators),
            "tags": [f"ioc.{ioc_type}"],
        })

        logger.info(
            f"Generated YARA rule: {rule_name}",
            extra={"ioc_type": ioc_type, "ioc_count": len(indicators), "severity": severity},
        )

    # Process chain detection rule (from malicious_commands)
    cmds = iocs.get("malicious_commands", [])
    procs = iocs.get("process_names", [])
    combined = cmds + procs
    if combined:
        combined = combined[:MAX_INDICATORS_PER_RULE]
        rule_name = "PERSEPTOR_Process_Chain_Detection"
        chain_strings = []
        for idx, item in enumerate(combined):
            safe_item = _sanitize_string(str(item))
            chain_strings.append(f'        $chain_{idx} = "{safe_item}" ascii wide nocase')

        strings_block = "\n".join(chain_strings)
        condition = _build_condition(len(combined))

        rule_text = f"""rule {rule_name}
{{
    meta:
        description = "Detects process execution chains and command patterns"
        author = "PERSEPTOR - Aytek AYTEMUR"
        date = "{current_date}"
        severity = "critical"
        reference = "Generated by PERSEPTOR AI Detection Platform"
        rule_id = "{str(uuid.uuid4())[:8]}"

    strings:
{strings_block}

    condition:
        {condition}
}}"""

        rules.append({
            "name": rule_name,
            "description": "Detects process execution chains and command patterns",
            "rule": rule_text,
            "severity": "critical",
            "ioc_type": "process_chain",
            "ioc_count": len(combined),
            "tags": ["ioc.process_chain", "ioc.execution"],
        })

        logger.info(f"Generated process chain YARA rule with {len(combined)} indicators")

    if not rules:
        logger.warning("No IoC indicators found for YARA rule generation")

    logger.info(f"Total YARA rules generated: {len(rules)}")
    return rules


def yara_rules_to_text(rules: List[dict]) -> str:
    """Convert structured YARA rules list to plain text output."""
    return "\n\n".join(r["rule"] for r in rules)


# ─── Legacy Compatibility ─────────────────────────────────────────────────────

def generate_yara_rules_legacy(analysis_data: dict) -> str:
    """
    Legacy-compatible function that returns YARA rules as a single text string.
    Used by existing api/app.py integration.
    """
    rules = generate_yara_rules(analysis_data)
    return yara_rules_to_text(rules)
